<!-- 
  * Reactive audio visualation demo for CIS367
  * Based on this tutorial: 
    * Creating an Interactive Spectrogram With Three.js and GLSL Shaders
    * (https://calebgannon.com/2021/01/09/spectrogram-with-three-js-and-glsl-shaders/
-->
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Hello world</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }
  </style>
</head>

<!-- shaders -->
<script type="x-shader/x-vertex" id="vertexshader">
  attribute float displacement;
  uniform vec3 vLut[1];
  varying vec3 vColor;

  void main() {
    vColor = vLut[0];
    vec3 newPosition = position + normal*displacement/25.5;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition,1.0);
  }
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
  varying vec3 vColor;
  void main() {
    gl_FragColor = vec4(vColor,1.0);
  }
</script>

<body>
  <div id="Spectrogram"></div>
  <script src="./libraries/threejs/three.min.js"></script>
  <script>
    // Initialize Scene parameters
    let frequency_samples = 128; // Y resolution
    let DATA = new Uint8Array(frequency_samples); // for later
    let camera, scene, renderer;
    let heights, mesh;
    let time_samples = 400; // X resolution
    let n_vertices = (frequency_samples + 1) * (time_samples + 1);
    let xsegments = time_samples;
    let ysegments = frequency_samples;
    let xsize = 35;
    let ysize = 20;
    let xhalfSize = xsize / 2;
    let yhalfSize = ysize / 2;
    let xsegmentSize = xsize / xsegments; //Size of one square
    let ysegmentSize = ysize / ysegments;

    init();

    function init() {
      // Place the camera in space
      camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 1000);
      camera.position.z = 64;
      scene = new THREE.Scene();
      let geometry = new THREE.BufferGeometry();
      let indices = [];
      heights = [];
      let vertices = [];

      // generate vertices for a simple grid geometry
      for (let i = 0; i <= xsegments; i++) {
        let x = (i * xsegmentSize) - xhalfSize; //midpoint of mesh is 0,0
        for (let j = 0; j <= ysegments; j++) {
          let y = (j * ysegmentSize) - yhalfSize;
          vertices.push(x, y, 0);
          heights.push(Math.random() * 255); // for now our mesh is flat, so heights are zero
        }
      }
      // Add the position data to the geometry buffer
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

      // generate indices (data for element buffer). This says where each triangle goes
      // the code might look complex, but it is essentially the way you tile the plane with 
      // triangles. Each square segment has 4 vertices, a, b, c, d. Which make 2 triangles.
      // a  b
      // d  c
      // Looking above, we can make a triangle by connecting a b d
      // a-b
      // d
      // and similarly for b c d. These make the two faces of our mesh segment.

      for (let i = 0; i < xsegments; i++) {
        for (let j = 0; j < ysegments; j++) {
          let a = i * (ysegments + 1) + (j + 1);
          let b = i * (ysegments + 1) + j;
          let c = (i + 1) * (ysegments + 1) + j;
          let d = (i + 1) * (ysegments + 1) + (j + 1);
          // generate two faces (triangles) per iteration
          indices.push(a, b, d); // face one
          indices.push(b, c, d); // face two
        }
      }
      geometry.setIndex(indices);
      // This bit of code defines a lookup table (LUT) for our colors. 
      // Right now we are only providing one color in this "string" value below (Red).
      // This will be useful later on when we want a variety of colors to work with
      // We will just add colors to this string and send them to the shader
      let string = [[0.5, 0.0, 0.0]];
      var lut = [];
      for (let n = 0; n < 1; n++) {
        lut.push(new THREE.Vector3((string[n][0] * 255 - 49) / 206., (string[n][1] * 255 - 19) / 236., (string[n][2] * 255 - 50) / 190.));
      }
      //Grab the shaders from the document
      var vShader = document.getElementById('vertexshader');
      var fShader = document.getElementById('fragmentshader');
      // Define the uniforms. V3V gives us a 3vector for RGB
      var uniforms = {
        vLut: { type: "v3v", value: lut }
      }
      // Bind the shaders and uniforms to the material
      let material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vShader.text,
        fragmentShader: fShader.text
      });

      // Initialize the renderer and connect it to the DIV
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      let container = document.getElementById('Spectrogram');
      container.appendChild(renderer.domElement);

      // Give the mesh a material with color (Purple)
      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
      geometry.setAttribute('displacement', new THREE.Uint8BufferAttribute(heights, 1));
      mesh.geometry.computeFaceNormals();
      mesh.geometry.computeVertexNormals();
      // Render the scene!
      renderer.render(scene, camera);
    }
  </script>
</body>

</html>